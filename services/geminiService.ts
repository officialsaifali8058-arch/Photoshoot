import { GoogleGenAI, Modality, GenerateContentResponse } from "@google/genai";
import { resizeImageToAspectRatio } from "../utils/imageUtils";
import { VariationConfig } from "../types";

// Initialize the Google Gemini API client.
// The API key is sourced from the `process.env.API_KEY` environment variable.
const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

/**
 * Parses the error from a Gemini API call and returns a user-friendly message.
 * @param error The error object from the catch block.
 * @param defaultMessage The default message to use if parsing fails.
 * @returns A user-friendly error message string.
 */
const parseGeminiError = (error: any, defaultMessage: string): string => {
    console.error("Gemini API Error:", error);
    try {
        // The error message from the API is often a JSON string in the message property
        const errorObj = JSON.parse(error.message);
        if (errorObj.error && errorObj.error.message) {
            return errorObj.error.message;
        }
    } catch (e) {
        // If parsing fails, it might be a simple string message
        return error.message || defaultMessage;
    }
    // Fallback if the JSON structure is unexpected
    return error.message || defaultMessage;
}

/**
 * Converts a base64 data URL to a GenerativePart object for the Gemini API.
 * @param base64 The base64 data URL (e.g., "data:image/png;base64,...").
 * @param mimeType The MIME type of the image.
 * @returns A GenerativePart object.
 */
const fileToGenerativePart = (base64: string, mimeType: string) => {
  return {
    inlineData: {
      data: base64.split(',')[1],
      mimeType,
    },
  };
};

/**
 * A helper function to process the Gemini API response for image generation.
 * It checks for safety issues and extracts the image data.
 * @param response The GenerateContentResponse from the Gemini API.
 * @returns The base64 data URL of the generated image.
 */
const processImageGenerationResponse = (response: GenerateContentResponse): string => {
    const candidate = response.candidates?.[0];

    // Check for safety blocks or other issues that would cause a lack of response
    if (!candidate || candidate.finishReason === 'SAFETY') {
        throw new Error("Request was blocked due to safety settings. Please try a different prompt or image.");
    }

    if (!candidate.content?.parts || candidate.content.parts.length === 0) {
        throw new Error("The AI model returned an empty response. Please try again.");
    }

    // Find the first image part in the response
    for (const part of candidate.content.parts) {
        if (part.inlineData) {
            const base64ImageBytes: string = part.inlineData.data;
            return `data:${part.inlineData.mimeType};base64,${base64ImageBytes}`;
        }
    }

    // If no image is found, it's possible the model responded with text instead
    const textPart = candidate.content.parts.find(p => p.text);
    if (textPart?.text) {
        throw new Error(`Model returned a text response instead of an image: "${textPart.text.substring(0, 100)}..."`);
    }
    
    // Fallback error if no image and no text explanation is found
    throw new Error("No image was generated by the model. The prompt might be too complex or unclear.");
};
  
/**
 * Generates a creative prompt based on an input image.
 * @param base64Image The base64 encoded image.
 * @param mimeType The MIME type of the image.
 * @returns A promise that resolves to the generated text prompt.
 */
export const generatePromptFromImage = async (base64Image: string, mimeType: string): Promise<string> => {
    try {
        const imagePart = fileToGenerativePart(base64Image, mimeType);
        const textPart = {
            text: "Analyze this photoshoot image. Describe its style, setting, lighting, composition, and mood in detail. Create a descriptive prompt for an AI image generator to replicate this exact style. IMPORTANT: The prompt you generate must explicitly state that the photoshoot should feature the user's uploaded reference face, preserving their exact identity, and not the person in this inspiration photo. Focus only on the aesthetic elements (style, lighting, etc.) that can be applied to a new subject."
        };
        // Use the 'gemini-2.5-flash' model for text generation from image and text input.
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: { parts: [imagePart, textPart] }
        });

        // Add safety check for text generation
        if (!response.candidates || response.candidates.length === 0 || response.candidates[0].finishReason === 'SAFETY') {
            throw new Error("Request was blocked due to safety settings. Please try a different inspiration image.");
        }
        
        // Extract the generated text from the response.
        return response.text.trim();
    } catch (error: any) {
        throw new Error(parseGeminiError(error, "Failed to generate prompt. Please try again."));
    }
};

/**
 * Generates a new image based on a base image and a text prompt.
 * @param base64Image The base64 encoded image.
 * @param mimeType The MIME type of the image.
 * @param prompt The text prompt describing the desired output.
 * @returns A promise that resolves to the base64 data URL of the generated image.
 */
export const generatePhotoshoot = async (base64Image: string, mimeType: string, prompt: string, aspectRatio: string): Promise<string> => {
    try {
        // Pre-process the image by padding it to the target aspect ratio.
        // This gives the model a strong hint about the desired output dimensions.
        const paddedImageBase64 = await resizeImageToAspectRatio(base64Image, aspectRatio);

        const imagePart = fileToGenerativePart(paddedImageBase64, 'image/png');
        
        // Add a more direct, instructional frame to the prompt to prevent conversational responses.
        const fullPrompt = `Using the provided image as the reference for the person's face and identity, generate a new photoshoot image with a ${aspectRatio} aspect ratio based on the following instructions. The input image has been padded to the correct aspect ratio; please fill the entire frame. Do not ask for the image, it is already provided. Instructions: ${prompt}`;
        const textPart = { text: fullPrompt };

        // Use the 'gemini-2.5-flash-image-preview' model for image editing tasks.
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash-image-preview',
            contents: { parts: [imagePart, textPart] },
            config: {
                // Response must include IMAGE modality to get an image back.
                responseModalities: [Modality.IMAGE, Modality.TEXT],
            },
        });
        
        return processImageGenerationResponse(response);

    } catch (error: any) {
        throw new Error(parseGeminiError(error, "Failed to generate image. The model may not be suitable for this request."));
    }
};

/**
 * Enhances an existing image to improve its quality.
 * @param base64Image The base64 encoded image to enhance.
 * @param mimeType The MIME type of the image.
 * @returns A promise that resolves to the base64 data URL of the enhanced image.
 */
export const enhanceImage = async (base64Image: string, mimeType: string): Promise<string> => {
    try {
        const imagePart = fileToGenerativePart(base64Image, mimeType);
        // Add a more direct, instructional frame to the prompt for robustness.
        const fullPrompt = `Task: Enhance the provided image. Instructions: Perform a super-resolution enhancement on this image. Upscale it to 4K quality, making a dramatic improvement in sharpness and clarity. Refine all details, creating flawless yet realistic skin texture, perfect lighting, and hyper-realistic features. The result must look like a high-end professional photograph, significantly better than the original. Preserve the subject's identity and composition.`;
        const textPart = { text: fullPrompt };
        
        // Use the 'gemini-2.5-flash-image-preview' model for image editing tasks.
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash-image-preview',
            contents: { parts: [imagePart, textPart] },
            config: {
                // Response must include IMAGE modality to get an image back.
                responseModalities: [Modality.IMAGE, Modality.TEXT],
            },
        });

        return processImageGenerationResponse(response);

    } catch (error: any) {
        throw new Error(parseGeminiError(error, "Failed to enhance image. Please try again."));
    }
};

/**
 * Generates one variation of an existing image based on a specific prompt.
 * @param base64Image The base64 encoded image to vary.
 * @param mimeType The MIME type of the image.
 * @param prompt The specific instruction for the variation.
 * @returns A promise that resolves to the base64 data URL of the new image variation.
 */
const generateSingleVariation = async (base64Image: string, mimeType: string, prompt: string): Promise<string> => {
    const imagePart = fileToGenerativePart(base64Image, mimeType);
    const textPart = { text: prompt };
    
    const response = await ai.models.generateContent({
        model: 'gemini-2.5-flash-image-preview',
        contents: { parts: [imagePart, textPart] },
        config: {
            responseModalities: [Modality.IMAGE, Modality.TEXT],
        },
    });

    return processImageGenerationResponse(response);
}

const buildVariationPrompt = (options: Record<string, boolean>): string => {
    if (options.aiChoice) {
        return "Task: Generate a creative variation of the provided image. Instructions: The person's identity, clothing, and the overall style must be perfectly preserved. You have creative freedom to make an interesting and high-quality variation that is noticeably different from the original. Surprise me.";
    }

    const changes = [];
    if (options.posture) changes.push("change the person's body posture (e.g., turn their shoulders, lean slightly, or subtly change their arm position)");
    if (options.cameraAngle) changes.push("change the camera angle (e.g., capture from a slightly lower or higher angle)");
    if (options.expression) changes.push("subtly change the facial expression (e.g., a slight smile, a more serious or thoughtful look)");
    if (options.direction) changes.push("change the direction of the person's face or gaze (e.g., have them look slightly away from the camera)");
    if (options.hyperRealistic) changes.push("make the image more hyper-realistic, enhancing details, sharpness, and lighting to a dramatic degree");
    
    if (changes.length === 0) return ''; // Should not happen if filtered in App.tsx

    const promptIntro = `Task: Generate a variation of the provided image. Instructions: The person's identity, clothing, and the overall style, lighting, and setting MUST be perfectly preserved. Your only task is to apply the following change(s): ${changes.join(', and ')}. The change should be noticeable but believable.`;
    return promptIntro;
};

/**
 * Generates multiple custom variations of an image based on user-selected options.
 * @param base64Image The base64 encoded image to vary.
 * @param mimeType The MIME type of the image.
 * @param variationConfigs An array of configuration objects, one for each desired variation.
 * @returns A promise that resolves to an array of base64 data URLs.
 */
export const generateCustomVariations = async (base64Image: string, mimeType: string, variationConfigs: VariationConfig[]): Promise<string[]> => {
    try {
        const results: string[] = [];
        for (let i = 0; i < variationConfigs.length; i++) {
            const config = variationConfigs[i];
            const prompt = buildVariationPrompt(config.options);
            
            if (prompt) {
                // Add a delay between requests to avoid hitting rate limits.
                if (i > 0) {
                    await new Promise(resolve => setTimeout(resolve, 2000));
                }
                const result = await generateSingleVariation(base64Image, mimeType, prompt);
                results.push(result);
            }
        }
        return results;

    } catch (error: any) {
        throw new Error(parseGeminiError(error, "Failed to generate variations. Please try again."));
    }
};
